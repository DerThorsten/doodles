<!DOCTYPE html>
<html>
<head>
<title>GMAN Doodles</title>
<meta charset="uft-8" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui">
<style>
html,body {
    background-color: #191919;
    font-family: monospace;
    color: #808080;
    margin: 0px;
    font-size: large;
}
h1 {
    font-size: inherit;
    font-weight: bold;
    margin: 10px;
    color: #a080f0;
    text-decoration: underline;
}
h2 {
    color: #acf0e9;
    font-size: inherit;
    font-weight: bold;
}
b {
    color: #c0ddd0;
    font-weight: normal;
}
.doodle {
    padding: 1em;
    margin-bottom: 10px;
}
.doodle:nth-child(odd) {
    gbackground-color: #202020;
}

h2:before {
    content: "$ ";
    color: #44e;
}
a:visited,
a:active,
a:link {
    color: #82b0fd;
}
a:hover,
a:focus {
    color: #ffb080;
}
</style>
</head>
<body>
<h1>Various Random Doodles by <a href="http://games.greggman.com">Greggman</a></h1>

<div class="doodle">
<h2>Textme</h2>
<p>This was an attempt at making a glyph postprocessing effect to turn whatever is
being displayed into text.</p>
<p><a href="textme01.html">textme01</a>: First step, make a grid of letters</p>
<p><a href="textme02.html">textme02</a>: Second step, organize by brightness</p>
<p><a href="textme03.html">textme03</a>: Third step, support different glyphs</p>
<p><a href="textme04.html">textme04</a>: Fourth step, render with it</p>
<p>Note: under <b>glyphs</b> de-select <b>ascii</b> and select <b>boxElements</b> and <b>geometricShapes</b>. Also
under <b>debug</b> select <b>dosColors</b>. Try changing the scene as well.
</div>


<div class="doodle">
<h2>Sketchtext</h2>
<p>an attempt to make lines look like they've been
sketched in a low framerate hand drawn animation kind of way. Still a work in progress.</p>
<p><a href="sketchtext01.html">sketchtext01</a></p>
</div>


<div class="doodle">
<h2>Scribble</h2>
<p>This was a step on the way to sketchtext. It's was easier to use built in primitives
first rather than figure out how to get the outlines of glyphs from a font.</p>
<p><a href="scribble01.html">scribble01</a></p>
<p><a href="scribble02.html">scribble02</a></p>
</div>


<div class="doodle">
<h2>Atom</h2>
<p>Not sure what this is. Just goofin</p>
<p><a href="atom03.html">atom03</a></p>
<p><a href="atom02.html">atom02</a></p>
<p><a href="atom01.html">atom01</a></p>
</div>


<div class="doodle">
<h2>Lightball</h2>
<p>A work in progress that started as <a href="http://stackoverflow.com/a/28471031/128511">an example to an answer on SO<a>.</p>
<p><a href="lightball03.html">lightball03</a></p>
<p><a href="lightball02.html">lightball02</a></p>
<p><a href="lightball01.html">lightball01</a></p>
<p><a href="http://stackoverflow.com/users/868679/brendan-annable">Brendan Annable</a> suggested moving
the vertices behind the camera in the vertex shader instead of discarding in the fragment shader
because that would be faster. The GPU will clip the triangle instead of trying to draw every pixel
and having it get discarded. So, here's those versions.</p>
<p><a href="lightball03-vertex-shader-discard.html">lightball03-vertex-shader-discard</a></p>
<p><a href="lightball02-vertex-shader-discard.html">lightball02-vertex-shader-discard</a></p>
<p><a href="lightball01-vertex-shader-discard.html">lightball01-vertex-shader-discard</a></p>
</div>


<div class="doodle">
<h2>Sort</h2>
<p>
A sort visualizer <a href="http://www.youtube.com/watch?v=kPRA0W1kECg">inspired by this video</a>.
</p><p>
Mostly I had just never personally implemented a quicksort.  I first
googled "quicksort explained" which bought up
<a href="http://www.youtube.com/watch?v=Z5nSXTnD1I4?">this AWESOME video that
extermely clearly explains the algorithm</a>.  So I implemented that.
</p><p>
But, then I found <a href="http://www.sorting-algorithms.com/">this page
which shows a bunch of algorthms and it has them detailed very tersely</a>.
Their quicksort is nothing like the one in the video above.  Their's moves
a random `pivot` through the array going only to the right where as the one
above uses the left most element as its `pivot`, takes it out of the array
and uses left and right pointers to move stuff before and after the pivot
finally inserting the pivot in the space found.
</p><p>
The LR one appears to be much faster than the right only one. I also don't quite
get the point of choosing a random pivot. I suppose it's to try to avoid the worst
case which I think is an inversely sorted array and starting from element #1. I'm sure
somewhere on the net explains why a random pivot is best for algo #2. I'm a little
worried there's a bug because the non LR one take so long on the uniform array example.
</p><p>
Anyway, I added a bunch more including the quicksort 3 way partition. I also added
cycle times but they make no sense currently. It's basically 2 cycles for a load,
3 for a store, 1 for a compare though a compare includes a load so it's 3 cycles.
But cache hits are not currently taken into account nor are a few array accesses
in the algos. Maybe the only thing you care about is array accesses and cache
misses in which case I should remove the various set, cmp, copy, swap stuff and
just add have get/put and count cycles and try to guess cache hits.
</p><p>
<a href="sort.html">sort.html</a>
</p>
</div>


<div class="doodle">
<h2>Circles</h2>

<p>
Inspired by an exhibit I saw about
<a href="http://en.wikipedia.org/wiki/Marcel_Duchamp">Marcel Duchamp</a>
at the Moderna Museet in Stockholm.</p>
</p><p>
<a href="circles.html">circles.html</a>
</p><p>
Some samples:
</p><p>
<a href="http://goo.gl/s8jsf7">http://goo.gl/s8jsf7</a>
</p><p>
<a href="http://goo.gl/IiIyng">http://goo.gl/IiIyng</a>
</p><p>
<a href="http://goo.gl/95hWX6">http://goo.gl/95hWX6</a>
</p>
</div>


<div class="doodle">
<h2>Spirograph</h2>

<p>
Inspired by Spirograph toys.
</p><p>
<a href="spirograph.html">spirograph.html</a>
</p><p>
Some Samples:
</p><p>
<a href="http://goo.gl/MJ9dwc">http://goo.gl/MJ9dwc</a>
</p><p>
<a href="http://goo.gl/vSgnT7">http://goo.gl/vSgnT7</a>
</p><p>
<a href="http://goo.gl/vvZq0N">http://goo.gl/vvZq0N</a>
</p><p>
<a href="http://goo.gl/yp5B4j">http://goo.gl/yp5B4j</a>
</p>
</div>


<div class="doodle">
<h2>Missile-Command</h2>

<p>
Written to demonstrate how the original Missile Command was created.
</p><p>
Most games today erase the entire display every frame.  Back when Missile
Command was created machines were not fast enough to draw the entire
display in pixels at 60 frames per second.  So, Missile Command never
erases the display.  Missiles or Bombs are just a line drawing function
drawing the lead pixel and then erasing that lead pixel with a trail
pixel.  This leaves the trail drawing only 2 pixels per frame per
bomb/missile.  To erase the trail the line is draw again with black.
</p><p>
The explosions similarly only draw the outer edge of the circle.  Because
nothing is erased the circle expands.  To clear the explosion black
circles are drawn in the opposite direction.
</p><p>
These techniques make the game fast even on the 1mhz machine it was
originally written on.  They also give some of Missile Command's
distinctive looks like when two explosions overlap one will start erasing
the other leaving crescent shapes. In this case though I'm using
HTML5's Canvas arc function to draw the circle. The original Missile
Command likely used a 1 pixel thick function to draw the circle.
Unfortunately HTML5 Canvas has no way to draw circles exactly 1 pixel
thick. I could implement my own circle function but I was too lazy.
</p><p>
The glowing colors were achieved back in the 80s by color cycling or
rather the system could only display 4 colors but you could choose
which 4 colors. By changing 1 of the 4 colors every frame to a different
color you'd get a glowing color "for free". Almost zero work on the part
of the processor. Systems today with their 24bit color displays can't
really do color cycling. To simulate color cycling requires re-drawing
every pixel that changes color either directly or through various GPU
techniques. Since Missile Command only really needs 1 glowing color
I achieve the glow by changing the background color of the canvas every
frame and filling it with opaque black. I draw the tips of the missiles
and the explosions by setting pixels to 0,0,0,0. This makes them show
the through to the background color. Since it's changing every frame
I get "free" glowing similar to the color cycling technique from the 80s.
</p><p>
<a href="missile-command.html">missile-command.html</a>
</p>
</div>

<div class="doodle">
<h2>Emoji-Draw</h2>

<p>
Just wanted to see if canvas supports drawing with emoji.
Yes on Safari 7+, FF 29+. No on Chrome as of v34.
</p><p>
<a href="emoji-draw.html">emoji-draw.html</a>
</p>
</div>


<div class="doodle">
<h2>Rects</h2>

<p>
Inspired by some t-shirt I saw at Design Festa 39
</p><p>
<a href="rects.html">rects.html</a>
</p>
</div>



<div class="doodle">
<h2>Tree-Color</h2>


<p>
Same as tree but each level is a different color.
</p><p>
<a href="tree-color.html">tree-color.html</a>
</p>
</div>



<div class="doodle">
<h2>Tree</h2>


<p>
Generating a simple tree.
</p><p>
<a href="tree.html">tree.html</a>
</p>
</div>



<div class="doodle">
<h2>Fork</h2>


<p>
Playing around with a forking structure.
</p><p>
<a href="fork.html">fork.html</a>
</p>
</div>



<div class="doodle">
<h2>Faces</h2>


<p>
Just a few types of eyes, eyebrows and mouths can generate many expressions
</p><p>
<a href="faces.html">faces.html</a>
</p>
</div>



</body>
</html>
